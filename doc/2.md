## 详细实现

### 信道

之前说过信道的实现是sender+receiver+seq_num确定唯一的消息。

#### 0.1.0

使用Redis ZSet实现，score为sqe_num，同时使用incr指令获取自增seq_num。

### 收件箱

收件箱只保存发送者，而不保存具体的消息。但是这里涉及到什么时候使用收件箱，一般而言是在用户连接断开时使用，但是如何准确快速的判断呢？

如果使用心跳机制，则最快判断时间取决于心跳间隔和超时次数，而盲目的缩小这二者会造成资源浪费。

所以通过向连接写数据失败来判断。比方说，一旦连接写入失败，便追加收件箱，因为所有的消息都会先写入到信道，所以单纯处理收件箱即可。

同时每一次客户端上线之后，在拉取消息之后清空收件箱即可，对于多客户端可以分别拉取，详见消息同步。

#### 0.1.0

使用Redis Set实现。

### 心跳

心跳设置为每指定时间发送一次，同时在内存保存指定用户上一次在线时间，如果超过设定间隔三次没有心跳则认为发生了下线。

### 消息同步

消息同步分为前向同步和后向同步，前向同步拉取指定消息前N条消息，后向同步拉取指定消息后N条消息。如果没有指定则默认前向同步，且起始位置为最新的消息。这里是针对某一信道而言。

所以这里需要客户端保存最新消息序号，并且作为拉取依据，如果是第一次登录则拉取最近七天的消息，当然了，一开始只拉取最近三天的即可。服务端仅保存最近七天的消息，并且可全平台同步。

所以拉取消息的参数应该有三个：方向，序号，数量(类似分页)。

在回复消息时，回复的第一条消息是本次同步请求返回的消息总数，然后依次跟着N条消息，按照seq_num排序。

### 消息发送成功回执

这里的回执指的是服务端对客户端的回执，而不是被发送客户端对服务端的回执，那就是企业微信和钉钉这种PUA玩意了。仅仅用于确定消息送达。回执与其对应的消息存在严格的顺序关系，所以不需要担心回执错乱的问题。

### 群消息

这里说一下群消息，对于群消息前面说了是把群当成用户处理，且所有群成员共享一个信道，但是如果群成员想要了解消息发送方，还需要额外的参数来记录，这里对群ID做限制，即所有的群ID都 >= u32::MAX << 1，所以一旦消息接收方满足这个条件，就知道这是一个群消息，那么payload部分会被追加一个发送者信息，然后跟着的才是消息本体，即payload前面的8字节是sender_id。

### 收件箱

收件箱为了保证绝对不遗漏(因为用户每次上线一定会检查一下的，所以如果这里遗漏了就会造成消息永远不被感知)，需要对每一条消息进行记录，同时使用时间顺序写入ZSet，可以做到同一个用户永远保存的都是他的最新消息记录，所以这里需要客户端自己去记录最新消息，并在下次上线时请求这个记录之后的收件箱。或者说需要客户端自行记录最后一次活跃时间——通过最新消息记录。另一种就是因为心跳的存在，可以让服务端记录最后一次心跳时间，然后直接返回此时间之后的收件箱，然后客户端自行去重整理。
