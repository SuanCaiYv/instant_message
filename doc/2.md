## 详细实现

### 信道

之前说过信道的实现是sender+receiver+seq_num确定唯一的消息。

#### 0.1.0

使用Redis ZSet实现，score为sqe_num，同时使用incr指令获取自增seq_num。

### 收件箱

收件箱只保存发送者，而不保存具体的消息。但是这里涉及到什么时候使用收件箱，一般而言是在用户连接断开时使用，但是如何准确快速的判断呢？

如果使用心跳机制，则最快判断时间取决于心跳间隔和超时次数，而盲目的缩小这二者会造成资源浪费。

所以通过向连接写数据失败来判断。比方说，一旦连接写入失败，便追加收件箱，因为所有的消息都会先写入到信道，所以单纯处理收件箱即可。

同时每一次客户端上线之后，在拉取消息之后清空收件箱即可，对于多客户端可以分别拉取，详见消息同步。

#### 0.1.0

使用Redis Set实现。

### 心跳

心跳设置为每指定时间发送一次，同时在内存保存指定用户上一次在线时间，如果超过设定间隔三次没有心跳则认为发生了下线。

### 消息同步

消息同步分为前向同步和后向同步，前向同步拉取指定消息前N条消息，后向同步拉取指定消息后N条消息。如果没有指定则默认前向同步，且起始位置为最新的消息。这里是针对某一信道而言。

所以这里需要客户端保存最新消息序号，并且作为拉取依据，如果是第一次登录则拉取最近七天的消息，当然了，一开始只拉取最近三天的即可。服务端仅保存最近七天的消息，并且可全平台同步。

所以拉取消息的参数应该有三个：方向，序号，数量(类似分页)。

在回复消息时，回复的第一条消息是本次同步请求返回的消息总数，然后依次跟着N条消息，按照seq_num排序。

### 消息发送成功回执

这里的回执指的是服务端对客户端的回执，而不是被发送客户端对服务端的回执，那就是企业微信和钉钉这种PUA玩意了。仅仅用于确定消息送达。回执与其对应的消息存在严格的顺序关系，所以不需要担心回执错乱的问题。

